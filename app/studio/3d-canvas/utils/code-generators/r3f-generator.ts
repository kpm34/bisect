/**
 * R3F Code Generator
 * Generates React Three Fiber code from scene data
 */

import { SceneObject } from '../../r3f/SceneSelectionContext';

interface LightingState {
  ambient: { enabled: boolean; intensity: number; color: string };
  directional: { enabled: boolean; intensity: number; color: string; position: [number, number, number]; castShadow: boolean };
  point: { enabled: boolean; intensity: number; color: string; position: [number, number, number]; distance: number };
  spot: { enabled: boolean; intensity: number; color: string; position: [number, number, number]; angle: number; penumbra: number };
  hemisphere: { enabled: boolean; intensity: number; skyColor: string; groundColor: string };
}

interface EnvironmentState {
  preset: string;
  background: boolean;
  blur: number;
  intensity: number;
}

interface GeneratorOptions {
  objects: SceneObject[];
  lighting: LightingState;
  environment: EnvironmentState;
  includeCanvas?: boolean;
  componentName?: string;
}

/**
 * Generate React Three Fiber component code
 */
export function generateR3FCode(options: GeneratorOptions): string {
  const {
    objects,
    lighting,
    environment,
    includeCanvas = true,
    componentName = 'BisectScene'
  } = options;

  const imports = generateImports(objects, includeCanvas);
  const lightingCode = generateLightingCode(lighting);
  const objectsCode = generateObjectsCode(objects);
  const environmentCode = generateEnvironmentCode(environment);

  if (includeCanvas) {
    return `// Generated by Bisect - https://bisect.app
${imports}

export default function ${componentName}() {
  return (
    <Canvas shadows>
      <PerspectiveCamera makeDefault position={[0, 5, 10]} fov={50} />
${environmentCode}
${lightingCode}
${objectsCode}
      <OrbitControls />
    </Canvas>
  )
}
`;
  } else {
    return `// Generated by Bisect - https://bisect.app
// Scene contents only - wrap in your own Canvas
${imports}

export default function ${componentName}() {
  return (
    <>
${environmentCode}
${lightingCode}
${objectsCode}
    </>
  )
}
`;
  }
}

function generateImports(objects: SceneObject[], includeCanvas: boolean): string {
  const fiberImports = includeCanvas
    ? ["import { Canvas } from '@react-three/fiber'"]
    : [];

  const dreiImports: string[] = [];

  if (includeCanvas) {
    dreiImports.push('OrbitControls', 'PerspectiveCamera', 'Environment');
  }

  // Check for 3D text
  if (objects.some(obj => obj.type === 'text3d')) {
    dreiImports.push('Text3D', 'Center');
  }

  const dreiLine = dreiImports.length > 0
    ? `import { ${dreiImports.join(', ')} } from '@react-three/drei'`
    : '';

  return [
    ...fiberImports,
    dreiLine,
    '',
  ].filter(Boolean).join('\n');
}

function generateLightingCode(lighting: LightingState): string {
  const lines: string[] = [];
  const indent = '      ';

  if (lighting.ambient.enabled) {
    lines.push(`${indent}<ambientLight intensity={${lighting.ambient.intensity}} color="${lighting.ambient.color}" />`);
  }

  if (lighting.directional.enabled) {
    const pos = lighting.directional.position;
    const shadow = lighting.directional.castShadow ? ' castShadow' : '';
    lines.push(`${indent}<directionalLight position={[${pos[0]}, ${pos[1]}, ${pos[2]}]} intensity={${lighting.directional.intensity}} color="${lighting.directional.color}"${shadow} />`);
  }

  if (lighting.point.enabled) {
    const pos = lighting.point.position;
    lines.push(`${indent}<pointLight position={[${pos[0]}, ${pos[1]}, ${pos[2]}]} intensity={${lighting.point.intensity}} color="${lighting.point.color}" distance={${lighting.point.distance}} />`);
  }

  if (lighting.spot.enabled) {
    const pos = lighting.spot.position;
    lines.push(`${indent}<spotLight position={[${pos[0]}, ${pos[1]}, ${pos[2]}]} intensity={${lighting.spot.intensity}} color="${lighting.spot.color}" angle={${lighting.spot.angle}} penumbra={${lighting.spot.penumbra}} castShadow />`);
  }

  if (lighting.hemisphere.enabled) {
    lines.push(`${indent}<hemisphereLight intensity={${lighting.hemisphere.intensity}} color="${lighting.hemisphere.skyColor}" groundColor="${lighting.hemisphere.groundColor}" />`);
  }

  return lines.length > 0 ? '\n' + lines.join('\n') + '\n' : '';
}

function generateEnvironmentCode(environment: EnvironmentState): string {
  const indent = '      ';
  const bgProp = environment.background ? ' background' : '';
  return `${indent}<Environment preset="${environment.preset}"${bgProp} blur={${environment.blur}} environmentIntensity={${environment.intensity}} />`;
}

function generateObjectsCode(objects: SceneObject[]): string {
  if (objects.length === 0) return '';

  const lines: string[] = [''];
  const indent = '      ';

  for (const obj of objects) {
    lines.push(`${indent}{/* ${obj.name} */}`);
    lines.push(generateSingleObject(obj, indent));
    lines.push('');
  }

  return lines.join('\n');
}

function generateSingleObject(obj: SceneObject, indent: string): string {
  const pos = `position={[${obj.position.join(', ')}]}`;
  const rot = obj.rotation.some(r => r !== 0) ? ` rotation={[${obj.rotation.join(', ')}]}` : '';
  const scl = obj.scale.some((s, i) => s !== 1) ? ` scale={[${obj.scale.join(', ')}]}` : '';

  if (obj.type === 'text3d') {
    return `${indent}<Center>
${indent}  <Text3D
${indent}    font="/fonts/helvetiker_regular.typeface.json"
${indent}    size={0.5}
${indent}    height={0.1}
${indent}    ${pos}${rot}${scl}
${indent}  >
${indent}    ${obj.text || 'Hello'}
${indent}    <meshStandardMaterial color="${obj.color}" />
${indent}  </Text3D>
${indent}</Center>`;
  }

  const geometry = getGeometryCode(obj.type);
  if (!geometry) return '';

  return `${indent}<mesh ${pos}${rot}${scl}>
${indent}  ${geometry}
${indent}  <meshStandardMaterial color="${obj.color}" />
${indent}</mesh>`;
}

function getGeometryCode(type: string): string {
  switch (type) {
    case 'box':
      return '<boxGeometry args={[1, 1, 1]} />';
    case 'sphere':
      return '<sphereGeometry args={[0.5, 32, 32]} />';
    case 'plane':
      return '<planeGeometry args={[2, 2]} />';
    case 'cylinder':
      return '<cylinderGeometry args={[0.5, 0.5, 1, 32]} />';
    case 'cone':
      return '<coneGeometry args={[0.5, 1, 32]} />';
    case 'torus':
      return '<torusGeometry args={[0.4, 0.15, 16, 48]} />';
    case 'capsule':
      return '<capsuleGeometry args={[0.3, 0.6, 8, 16]} />';
    default:
      return '';
  }
}

/**
 * Generate scene-only code (no Canvas wrapper)
 */
export function generateR3FSceneCode(options: Omit<GeneratorOptions, 'includeCanvas'>): string {
  return generateR3FCode({ ...options, includeCanvas: false });
}
