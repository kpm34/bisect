/**
 * Vanilla Three.js Code Generator
 * Generates plain Three.js code from scene data
 */

import { SceneObject } from '../../r3f/SceneSelectionContext';

interface LightingState {
  ambient: { enabled: boolean; intensity: number; color: string };
  directional: { enabled: boolean; intensity: number; color: string; position: [number, number, number]; castShadow: boolean };
  point: { enabled: boolean; intensity: number; color: string; position: [number, number, number]; distance: number };
  spot: { enabled: boolean; intensity: number; color: string; position: [number, number, number]; angle: number; penumbra: number };
  hemisphere: { enabled: boolean; intensity: number; skyColor: string; groundColor: string };
}

interface EnvironmentState {
  preset: string;
  background: boolean;
  blur: number;
  intensity: number;
}

interface GeneratorOptions {
  objects: SceneObject[];
  lighting: LightingState;
  environment: EnvironmentState;
  format?: 'module' | 'script';
}

/**
 * Generate vanilla Three.js code
 */
export function generateVanillaCode(options: GeneratorOptions): string {
  const { objects, lighting, format = 'module' } = options;

  if (format === 'module') {
    return generateModuleCode(objects, lighting);
  } else {
    return generateScriptCode(objects, lighting);
  }
}

function generateModuleCode(objects: SceneObject[], lighting: LightingState): string {
  const objectsCode = objects.map((obj, i) => generateVanillaObject(obj, i)).join('\n\n');
  const lightingCode = generateVanillaLighting(lighting);

  return `// Generated by Bisect - https://bisect.app
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

// Scene setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x1a1a2e);

// Camera
const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 5, 10);

// Renderer
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.shadowMap.enabled = true;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
document.body.appendChild(renderer.domElement);

// Controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

// Lighting
${lightingCode}

// Objects
${objectsCode}

// Animation loop
function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}

// Handle resize
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

animate();
`;
}

function generateScriptCode(objects: SceneObject[], lighting: LightingState): string {
  const objectsCode = objects.map((obj, i) => generateVanillaObject(obj, i)).join('\n\n');
  const lightingCode = generateVanillaLighting(lighting);

  return `<!-- Generated by Bisect - https://bisect.app -->
<!DOCTYPE html>
<html>
<head>
  <title>Bisect Scene</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/examples/jsm/controls/OrbitControls.js": "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js"
    }
  }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a2e);

    // Camera
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 10);

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    document.body.appendChild(renderer.domElement);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // Lighting
${lightingCode.split('\n').map(l => '    ' + l).join('\n')}

    // Objects
${objectsCode.split('\n').map(l => '    ' + l).join('\n')}

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    // Handle resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
  </script>
</body>
</html>`;
}

function generateVanillaLighting(lighting: LightingState): string {
  const lines: string[] = [];

  if (lighting.ambient.enabled) {
    lines.push(`const ambientLight = new THREE.AmbientLight('${lighting.ambient.color}', ${lighting.ambient.intensity});`);
    lines.push('scene.add(ambientLight);');
    lines.push('');
  }

  if (lighting.directional.enabled) {
    const pos = lighting.directional.position;
    lines.push(`const directionalLight = new THREE.DirectionalLight('${lighting.directional.color}', ${lighting.directional.intensity});`);
    lines.push(`directionalLight.position.set(${pos[0]}, ${pos[1]}, ${pos[2]});`);
    if (lighting.directional.castShadow) {
      lines.push('directionalLight.castShadow = true;');
      lines.push('directionalLight.shadow.mapSize.width = 2048;');
      lines.push('directionalLight.shadow.mapSize.height = 2048;');
    }
    lines.push('scene.add(directionalLight);');
    lines.push('');
  }

  if (lighting.point.enabled) {
    const pos = lighting.point.position;
    lines.push(`const pointLight = new THREE.PointLight('${lighting.point.color}', ${lighting.point.intensity}, ${lighting.point.distance});`);
    lines.push(`pointLight.position.set(${pos[0]}, ${pos[1]}, ${pos[2]});`);
    lines.push('scene.add(pointLight);');
    lines.push('');
  }

  if (lighting.spot.enabled) {
    const pos = lighting.spot.position;
    lines.push(`const spotLight = new THREE.SpotLight('${lighting.spot.color}', ${lighting.spot.intensity});`);
    lines.push(`spotLight.position.set(${pos[0]}, ${pos[1]}, ${pos[2]});`);
    lines.push(`spotLight.angle = ${lighting.spot.angle};`);
    lines.push(`spotLight.penumbra = ${lighting.spot.penumbra};`);
    lines.push('spotLight.castShadow = true;');
    lines.push('scene.add(spotLight);');
    lines.push('');
  }

  if (lighting.hemisphere.enabled) {
    lines.push(`const hemisphereLight = new THREE.HemisphereLight('${lighting.hemisphere.skyColor}', '${lighting.hemisphere.groundColor}', ${lighting.hemisphere.intensity});`);
    lines.push('scene.add(hemisphereLight);');
    lines.push('');
  }

  return lines.join('\n');
}

function generateVanillaObject(obj: SceneObject, index: number): string {
  const varName = sanitizeVarName(obj.name) || `object${index}`;
  const geometry = getVanillaGeometry(obj.type);

  if (!geometry) return `// Skipped: ${obj.name} (unsupported type: ${obj.type})`;

  if (obj.type === 'text3d') {
    return `// 3D Text: "${obj.text || 'Hello'}"
// Note: Text geometry requires FontLoader - see Three.js docs
// const ${varName} = createTextMesh('${obj.text || 'Hello'}');`;
  }

  const lines = [
    `// ${obj.name}`,
    `const ${varName}Geometry = ${geometry};`,
    `const ${varName}Material = new THREE.MeshStandardMaterial({ color: '${obj.color}' });`,
    `const ${varName} = new THREE.Mesh(${varName}Geometry, ${varName}Material);`,
    `${varName}.position.set(${obj.position.join(', ')});`,
  ];

  if (obj.rotation.some(r => r !== 0)) {
    lines.push(`${varName}.rotation.set(${obj.rotation.join(', ')});`);
  }

  if (obj.scale.some(s => s !== 1)) {
    lines.push(`${varName}.scale.set(${obj.scale.join(', ')});`);
  }

  lines.push(`scene.add(${varName});`);

  return lines.join('\n');
}

function getVanillaGeometry(type: string): string {
  switch (type) {
    case 'box':
      return 'new THREE.BoxGeometry(1, 1, 1)';
    case 'sphere':
      return 'new THREE.SphereGeometry(0.5, 32, 32)';
    case 'plane':
      return 'new THREE.PlaneGeometry(2, 2)';
    case 'cylinder':
      return 'new THREE.CylinderGeometry(0.5, 0.5, 1, 32)';
    case 'cone':
      return 'new THREE.ConeGeometry(0.5, 1, 32)';
    case 'torus':
      return 'new THREE.TorusGeometry(0.4, 0.15, 16, 48)';
    case 'capsule':
      return 'new THREE.CapsuleGeometry(0.3, 0.6, 8, 16)';
    default:
      return '';
  }
}

function sanitizeVarName(name: string): string {
  return name
    .replace(/[^a-zA-Z0-9_]/g, '_')
    .replace(/^[0-9]/, '_$&')
    .toLowerCase();
}

export function generateVanillaModuleCode(options: Omit<GeneratorOptions, 'format'>): string {
  return generateVanillaCode({ ...options, format: 'module' });
}

export function generateVanillaScriptCode(options: Omit<GeneratorOptions, 'format'>): string {
  return generateVanillaCode({ ...options, format: 'script' });
}
